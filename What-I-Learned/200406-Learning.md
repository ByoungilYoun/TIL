# 컴퓨터 개론   

---

Contents    
1. History   
2. 기본 개념   

---   

## History   

- 1세대 컴퓨터 (1951-1959) : 진공관, 주 기억 장치 = 자기드럼     

- 2세대 컴퓨터 (1959 -1965) : 트랜지스터      
			   증폭작용과 스위칭 역할을 하는 반도체 소자   
			   진공관에 비해 작고 안정적이며 빠르고 저렴    

- 3세대 컴퓨터 (1965-1971) : 직접회로(IC, Integrated Circuit)    
			  하나의 기판에 여러 전자소자를 초소형으로 집적하여 서로 분리될수 없는    
			  구조로 만든 회로. 컴퓨터 소형화, 대량생산, 가격 하락,  성능 향상    
			  시분할 처리    
 			  무어의 법칙(1965년) : 고든 무어. 직접회로의 성능이 24개월 마다 2배가 된다는 법칙     

- 4세대 컴퓨터 (1971-1983) : 고밀도 직접 회로(LSI, Large Scale Integration)    
			  마이크로 프로세서 개발, 개인용 컴퓨터를 대량으로 생산할 수 있게 된 계기    

- 5세대 컴퓨터 (1984-) : 초고밀도 직접 회로 (VLSI, Very Large Scale Integration)     
	    	      5세대를 ULSI 또는 AI 세대라고 하기도 함    


## 기본 개념   

1. **Computer**  = compute + er : 계산한다는 뜻의 라틴어 computare 에서 유래    

2. **Coding** = code + ing : 	컴퓨터가 이해할수 있는 코드를 만드는 것     

3. **Programming**  = program + ing : 프로그램을 만들어내는 것     

4. **컴퓨터 프로그램** : 컴퓨터에 의해 실행되는 지시사항의 모음인 컴퓨터 소프트웨어의 한 예이다.    
	  	     대부분의 프로그램은 실행 중에 사용자의 입력에 반응하도록 구현된 명령어    
		     의 집합으로 구성되어 있다. 대부분의 프로그램들은 하드디스크 등의 매체에     
		     바이너리 형식의 파일로 저장되어 있다가 사용자가 실행시키면 메모리로      
		     적재되어 실행된다.      

5. **프로세스**  : 컴퓨터에서 실행중인 프로그램(일, task) 을 뜻합니다.     

6. **클럭** == 초당 처리하는 전기 신호 (0,1) 의 빈도 수, 1GHz = 10 억 번    

7. **코어** : 코어는 Core, 말 그대로 CPU의 중심을 말합니다.    
	  이 코어 안에서 모든 컴퓨터의 연산을 할 수 있다.    
	  코어가 많을수록 CPU가 "일반적으로" 좋다고 볼수있다.   
	  듀얼코어면 코어가 2개, 쿼드코어면 코어가 4개.... 이런식으로 한 CPU 안에 붙어있다 생각하면 된다.     

  **쓰레드** : CPU 코어가 사람의 뇌라면 쓰레드는 사람의 손이라 비유. 뇌가 생각하고 손이 움직여서    
	    일을 처리. 보통 코어 1개당 쓰레드 1개가 기본인데 하이퍼 쓰레딩 기술로 코어 1개당 쓰레드 2개가 된다.     
            인텔의 샐러론 -> 팬티엄 -> i3 -> i5 -> i7 -> i9 ( 코어와 쓰레드 개수가 다름, 속도 차이)     

8. **Hyper-Threading** : 하나의 프로세서가 2개의 논리적 프로세서처럼 작동하도록 하는 기술. 일종의     
		     SMT(Simultaneous Multi-threading) 기술로, 중앙 처리 장치(CPU)에서 하나의 CPU가 다중 스레드    
		     로 되어 동시에 2개의 프로세스가 가능하게 되는 것이다.        

9. **스레드** : 컴퓨터 프로그램 수행 시 프로세스 내부에 존재하는 수행 경로, 즉 일련의 실행 코드. 프로세스는 단순한 껍데기일 뿐, 실제 작업은 스레드가 담당한다. 프로세스 생성 시 하나의 주 스레드가 생성되어 대부분의 작업을 처리하고 주 스레드가 종료되면 프로세스도 종료된다. 하나의 운영 체계에서 여러 개의 프로세스가 동시에 실행되는 환경이 멀티태스킹이고, 하나의 프로세스 내에서 다수의 스레드가 동시에 수행되는 것이 멀티스레딩이다         

10. **CPU 동작 과정**   

11. **주기억장치 (RAM)** : 프로그램이 실행될 때 보조기억장치로부터 프로그램이나 자료를 이동시켜 실행시킬 수 있는 기억장소로 전원이 끊어져도 기억된 내용이 보존되는 롬(ROM)과 전원이 꺼지면 모든 내용이 지워지는 휘발성 메모리 타입의 램(RAM)이 있다. 램에는 에스램(static RAM)과 디램(dynamic RAM)이 있다. 에스램은 전원이 공급되는 동안은 기억된 내용이 유지되고, 디램은 전원이 공급되어도 주기적으로 충전(refresh)을 하여 주어야 기억된 자료가 유지된다. 디램은 주로 대용량 기억장치에 사용된다.    

12. **캐시 메모리** : 컴퓨터 속에 장착해 속도를 빠르게 하는 임시메모리이다. 컴퓨터의 속도를 이야기할 때에는 일반적으로 CPU(중앙처리장치)의 속도를 이야기한다. 이는 CPU의 속도에 의해 컴퓨터의 속도가 결정될 정도로 CPU에 비해 상대적으로 주변기기의 속도가 매우 느리다는 것을 나타낸다. 이러한 문제점을 해결하기 위하여 주변기기의 속도를 빠르게 하는 대표적인 방법이 캐시메모리이다. 하드디스크의 속도는 램보다 매우 느리다. 매번 프로그램을 실행시킬 때마다 디스크를 읽어야 하므로 속도가 느릴 수밖에 없다. 따라서 램과 디스크 사이에 일정량의 임시메모리를 만들고 처음 프로그램을 실행할 때 램으로 들어오는 내용을 그 임시메모리에도 보관한다. 그런 다음 프로그램을 실행시키면 하드디스크가 아닌 임시메모리에서 읽어오게 되기 때문에 읽어오는 시간이 매우 빨라지게 된다. 이 임시메모리를 캐시메모리라고 한다.    

13. **스택 (Stack)** : 모든 원소들의 삽입(insert)과 삭제(delete)가 리스트의 한쪽 끝에서만 수행되는 
		   제한 조건을 가지는 선형 자료 구조로서, 삽입과 삭제가 일어나는 리스트의 끝을 
      		   top 이라 하고, 다른 한쪽 끝을 bottom 이라 한다  LIFO(Last In First Out), FILO(First In Last Out)
		   프링글스, 탄창, 대형마트 카트 등
		   웹 브라우저 히스토리 (뒤로 가기), 실행 취소 등    

14. **큐 (Queue)** : 리스트의 한쪽 끝에서만 삽입과 삭제가 일어나는 스택과는 달리 리스트의 한쪽 끝에
	         서는 원소들이 삭제되고 반대쪽 끝에서는 원소들의 삽입만 가능하게 만든 
                 순서화된 리스트. 가장 먼저. 리스트에 삽입된 원소가 가장 먼저 삭제되므로 
                 선입 선출(先入先出)인 FIFO(first in first out) 리스트라고 한다 
    	         FIFO(First In First Out), LILO ( Last In Last Out)
		 은행 대기열, 컨테이너 벨트 등
	         값을 추가하는 것 : Enqueue 또는 Put
	         값을 꺼내오는 것 : Dequeue 또는 Get   

15. **Data Unit** : 1) Bit : 0,1/ on, off/ true, false. 두 가지 상태만을 표현하며 정보 표현의 최소 단위   
		    2) Nibble : 1nibble = 4bit     
		    3) Byte : 일정한 개수의 비트로 이루어진 비트열. 기본적으로 1byte = 8bit. 문자 하나    
			      를 나타내는 최소 단위     
		    4) Word : 프로세서 설계를 위한 주요 특성. CPU 레지스터와 메모리 사이에 한 번의    
		              연산에 전송할 수 있는 데이터 단위(32, 64 Bit 프로세서 등)      
			      이에 따라 주요 데이터 타입 사이즈가 달라지기도 함     

16. **진법** : 수를 셀 때 자리수가 올라가는 단위를 기준으로 셈법의 총칭     

17. **2의 보수를 사용해서 음수를 표현**    

18. **Data Size**   

1) k = kilo = 10^3 = 1000 ,                  2^10 = 1024    

2) M = Mega = 10^6 = 1000^2  ,               2^20 = 1024^2      

3) G = Giga = 10^9 = 1000^3,                 2^30 = 1024^3      

4) T = Tera =  10^12 = 1000^4,               2^40 = 1024^4     

1KB = 1024 Byte     
1MB = 1024 KB      
1GB = 1024 MB         

19. **논리 연산자 (Logical Operation)**  : And (&&) , Or(||) , Not (!)    

20. **비트 연산자 (Bitwise Operation)** : And( &) , Or ( | ),  XOR ( ^ ),   보수 연산 ( ~ ) , 왼쪽 시프트 연산자 ( << ),
        오른쪽 시프트 연산자 ( >> )     

21. **명명 규칙 (Naming Convention)** :     

- Pascal case (Upper camel case) : 모든 단어의 첫 시작 부분을 대문자로 표기. Swift 에서는 filename, class, struct, enum, protocol 및 type 에 대해 이것을 사용    

- Camel case (Lower camel case) - 시작 부분을 제외한 각 단어의 첫 글자를 대문자로 표기. Swift 에서는 변수명, 함수, 메서드 등 pascal case 이외에 모두 camel case 사용    

- Hungarian case - 각 타입의 축약어를 변수명의 접두어로 사용하는 방식    

- Snake case - 변수명의 각 단어를 언더바 ( _ ) 를 통해서 구분. Python 등의 언어에서 사용    

- Kebab case - 변수명의 각 단어를 하이픈 ( - ) 을 통해서 구분. Lisp 등의 언어에서 사용     

22. **고정 소수점 과 부동 소수점**   

- 고정 소수점 (fixed point) 방식 : 실수는 보통 정수부와 소수부로 나눌수 있다. 따라서 실수를 표현하는 가장 간단한 방식은 소수부의 자릿수를 미리 정하여 고정된 자릿수의 소수를 표현 하는 것.     

- 부동 소수점 (floating point) 방식 : 실수는 보통 정수부와 소수부로 나누지만, 가수부와 지수부로 나누어 표현할 수도 있다. 부동 소수점 방식은 이렇게 하나의 실수를 가수부와 지수부로 나누어 표현하는 방식. 고성 소수점 방식은 제한된 자릿수로 인해  표현할 수 있는 범위가 매우 작았는데 부동 소수점 방식은 매우 큰 실수까지도 표현할 수 있다.     

* 참조링크 : <https://blog.naver.com/ghdalswl77/221739761282>    





