# 4.화면전환 

---

iOS 에서 화면을 전환하는 방법에는 크게 2가지가 있다. 하나는 소스 코드를 통해 전환하는 방식이고, 또 다른 하나는 스토리보드가 제공하는 기능을 이용하여 전환하는 방식이다.  보통 전자를 프로그래밍적으로 화면을 전환한다, 또는 동적으로 화면을 전환한다고 하고 후자를 GUI 방식으로 화면을 전환한다, 또는 정적으로 화면을 전환한다 라고 한다.    

차이는 특정 상황에 대응할 수 있느냐 아니냐를 기준으로 나눈다. 동적인 방식은 특정 상황에 대응할 수 있지만 조금 복잡하고 어려운 반면, 정적인 방식은 일괄적으로 적용되는 것이라 특정 상황에 대응하기 어렵지만 그만큼 구현하기 쉽다. 

---

## 4.1 iOS 에서의 화면 전환 개념

1)  iOS 에서 화면 전환 방식은 분류 기준에 따라 크게 4가지 정도로 나누어 볼 수 있다.

- 뷰 컨트롤러의 뷰 위에 다른 뷰를 가져와 바꿔치기 하기 (특수한 상황에서 제한적으로 사용하는 방식)

-  뷰 컨트롤러에서 다른 뷰 컨트롤러를 호출하여 화면 전환하기

- 내비게이션 컨트롤러를 사용하여 화면 전환하기

- 화면 전환용 객체 세그웨이(Segueway)를 사용하여 화면 전환하기 

첫 방식을 제외한 나머지 방식들은 모두 뷰 컨트롤러를 호출하는 방식으로 이루어 진다. 전환할 화면을 담당하는 뷰 컨트롤러의 인스턴스를 생성하고, 이를 불러들여서 기존의 화면 위에 덮으면 화면이 전환된다. 

2) iOS 에서 화면 전환은 다음 두 가지 특성을 가진다. 

- 다음 화면으로 이동하는 방법과 이전 화면으로 되돌아가는 방법이 다름
- 화면 전환 방식에 따라 이전 화면으로 되돌아가는 방법이 다름

---

## 4.2 화면 전환 기법1 : 뷰를 이용한 화면 전환 

iOS 에서 화면을 전환할 때 사용할 수 있는 첫 번째 방법은 뷰를 사용하는 것이다. 좀 더 자세히 이야기 하면 하나의 뷰 컨트롤러 안에 두 개의 루트 뷰를 준비한 다음 , 상태에 따라 뷰를 적절히 교체해 주는 것. 그러나 이 방식은 하나의 뷰 컨트롤러가 두 개 이상의 루트 뷰를 관리해야 하므로 그리 좋은 방법은 아니다. iOS에서는 하나의 뷰 컨트롤러 아래에 하나의 루트 뷰를 관리하는 MVC 패턴을 기본으로 하는데, 위에서 설명한 방식은 이같은 구조를 완전히 거스르는 방식이기 때문. 

---

## 4.3 화면 전환 기법2 : 뷰 컨트롤러 직접 호출에 의한 화면 전환 

두 번째 방법은 현재의 뷰 컨트롤러에서 이동할 대상 뷰 컨트롤러를 직접 호출해서 화면을 표시하는 방식이다. 직접 표시한다는 의미에서 **프레젠테이션 방식** 이라고 부르기도 한다. 

화면을 표시하는 모든 뷰 컨트롤러는 UIViewController 클래스를 상속받는데, 이 클래스에서 정의된 다음 메소드를 사용하면 화면을 전환할 수 있다. 

```swift
present (<새로운 뷰컨트롤러 인스턴스> , animated : <애니메이션 여부>)
```

이 메소드는 두 개의 인자값을 입력받는데, 첫 번째 인자값은 새로운 화면을 담당하는 뷰 컨트롤러의 인스턴스이다. 화면을 전환할 때에는 필요에 따라 애니메이션 효과를 줄 수 있는데, 프레젠트 메소드의 두 번째 인자값이 이를 결정. 두 번째 인자값에 false를 입력하면 아무런 효과 없이 그냥 화면이 바뀌어 버리지만, true 를 입력하면 화면 전환 시 애니메이션 효과가 적용된다. 

때로는 화면 전환이 완료되는 시점에 맞추어 특정 로직을 실행해 주어야 할 경우도 있다.  이때는 다음 메소드를 사용

```swift
present (_ animated : completion: )
```

이 매개변수는 실행 구문을 클로저나 함수 형식으로 입력받아, 화면 전환이 완전히 끝난 후에 호출해 주는 역할을 한다. 

화면을 전환할 때 프레젠트 메소드를 이용했다면, 이전 화면으로 복귀할 때는 복귀 메소드를 사용

```swift
dismiss (animated : true)
```

여기서 주의해야 할 점은 화면을 걷어내는 주체가 자기 자신이 아니라는 점이다. iOS 에서 화면이 사라지게 처리하는 것은 사라질 화면의 뷰 컨트롤러 자신이 아니라 자신을 띄우고 있는 이전 뷰 컨트롤러 이다. 즉  **presentingViewController** 는 이것을 위해 필요한 속성이다. 화면을 내려달라고 요청할 대상을 참조 할 수 있어야 하기 때문이다. 

``` swift
self.presentingViewController?.dismiss(animated : )
```

스토리보드에서 화면 전환을 해보자 . 뷰 컨트롤러를 하나 더 만들어서 두개의 뷰 컨트롤러를 생성하고 첫번째 뷰 컨트롤러에 화면이동을 할 버튼을 만들어준다. 

```swift
@IBAction func moveNext(sender : Any ) {
  // 이동할 뷰 컨트롤러 객체를 StoryboardID 정보를 이용하여 참조.
  let uvc = self.storyboard!.instantiateViewController(withIdentifier : "SecondVC")
  
  // 화면 전환 할 때의 애니메이션 타입 
  uvc.modalTransitionStyle = UIModalTransitionStyle.coverVertical 
  
  // 인자값으로 뷰 컨트롤러 인스턴스를 넣고 프레젠트 메소드 호출
  self.present(uvc, animated : true)
}
```

---

## 4.4 내비게이션 컨트롤러를 이용한 화면 전환 

- 내비게이션 컨트롤러는 뷰 컨트롤러의 특별한 종류로, 계층적인 성격을 띠는 콘텐츠 구조를 관리하기 위한 컨트롤러 이다. 앱의 내비게이션을 표시해줄 수 있는 내비게이션 바가 내장되어있다. 

- 내비게이션 컨트롤러는 뷰 컨트롤러들의 전환을 직접 컨트롤하고, 앱의 내비게이션 정보를 표시하는 역할을 할 뿐만 아니라 화면 전환이 발생하는 뷰 컨트롤러들의 포인터를 스택으로 관리하여 원하는 화면에 접근하기 쉽게 한다. 

- 내비게이션 컨트롤러는 뷰 컨트롤러들의 계층적 구조를 관리하는 역할이기 때문에, 직접 콘텐츠를 담고 화면을 구성하지는 않는다.   대신 다른 뷰 컨트롤러들을 포함하고 있다. 이 때문에 스토리보드에서 보이는 것과 다르게 독립된 자신만의 화면을 가지지 않는 대신, 이 컨트롤러가 제어하는 모든 뷰 컨트롤러에 내비게이션 바를 생성하는 특징이 있다. 

- 내비게이션 컨트롤러는 항상 콘텐츠 계층 구조의 시작점 역할을 하는 뷰 컨트롤러와 함께 다니는데, 이를 **루트 뷰 컨트롤러** 라고 한다. 

- 내비게이션 컨트롤러는 화면에 현재 표시되고 있는 뷰 컨트롤러들을 **내비게이션 스택** 을 이용하여 관리한다. 내비게이션 스택은 배열 형식으로 되어있는데 배열을 세로로 쌓았다고 할 때, 가장 아래에 있는 첫 번째 뷰 컨트롤러는 루트 뷰 컨트롤러 이고, 최상위에 있는 마지막 뷰 컨트롤러는 현재 화면에 표시되고 있는 뷰 컨트롤러 이다. 

- 기본적으로 스택의 최상위에 뷰 컨트롤러를 추가할 때는 pushViewController( _ animated : ) 메소드를 사용하고 반대로 스택의 최상위 뷰 컨트롤러를 제거할 때에는 popViewController( _ animated : ) 메소드를 사용한다. 

- 내비게이션 컨트롤러를 사용하기 위한 Step

  1. 내비게이션 컨트롤러를 추가하는 방법은 Embed In 기능을 이용한다. 이 기능은 스토리보드에서 선택된 뷰 컨트롤러를 루트 뷰 컨트롤러로 삼아 내비게이션 컨트롤러만 추가해 준다. 

  2. 내비게이션 바에 내비게이션 아이템(Navigation Item) 이라는 객체를 추가해줘서 내장된 내비게이션 바에 타이틀을 작성할 수 있다. 
  3. 오브젝트 라이브러리에서 Bar Button Item을 찾아 내비게이션 바에 버튼을 추가해 준다.  

```swift
// 내비게이션 컨트롤러에서 화면 이동 버튼
@IBAction func moveByNavi(_ sender : Any) {
  // 두번째 뷰 컨트롤러 인스턴스를 가져온다. 
  guard let uvc = self.storyboard?.instantiateViewController(withIdentifier : "SecondVC") else{
    return 
  } 
  // 화면을 전환한다. 
  self.navigationController?.pushViewController(uvc, animated : true)
}
```

- 내비게이션 컨트롤러는 직접 연결된 루트 뷰 컨트롤러뿐만 아니라 내비게이션 컨트롤러가 제어하는 모든 뷰 컨트롤러의 상단에 내비게이션 바를 삽입하여 자신의 존재를 알게 한다. 
- 내비게이션 컨트롤러는 각 뷰 컨트롤러 마다 내장된 내비게이션 바에 이전 화면으로 되돌아갈 수 있는 버튼을 자동으로 만들어 준다. present(_ animated : ) 메소드를 이용해서 화면을 전환 할때 처럼 뒤로 가기 버튼을 직접 만들어 줄 필요가 없다는 뜻이다. 내비게이션 빠에서 뒤로 가기 버튼이 자동으로 추가되는 위치는 왼쪽이다. 자동으로 생성된 뒤로 가기 버튼의 타이틀은 이전 화면의 내비게이션 바에 작성된 타이틀과 같다. 

``` swift
@IBAction func back ( _ sender : Any) {
  self.navigationController?.popViewController(animated : true)
}
```

- present(_ animated :) 메소드의 호출 대상은 뷰 컨트롤러 자신이지만 pushViewController(_ animated:) 메소드의 호출 대상은내비게이션 컨트롤러 (self.navigationController) 이다. 

---

## 4.5 세그웨이를 이용한 화면 전환

- 세그웨이(Segue) 라고 불리는 객체는 스토리보드에서 뷰 컨트롤러 사이의 연결 관계 및 화면 전환을 관리하는 역할을 한다. 세그웨이는 화면과 화면을 연결하기 위해 아무런 소스 코드도 필요로 하지 않는다는 특징이 있는데, 뷰 컨트롤러와 뷰 컨트롤러 또는 화면 전환의 매개체가 되는 버튼과 컨트롤러 사이를 직접 연결하는 식으로 화면 전환 관계를 구성한다. 
- 스토리보드상에서 세그웨이는 뷰 컨트롤러 사이에 연결된 화살표로 표시된다. 이 화살표는 한쪽 방향으로 향하는 모습을 하고 있는데, 이는 출발지와 목적지가 있다는 뜻. 세그웨이는 한쪽 방향으로만 흐르는 화면 전환이다. 
- 소스 코드를 이용해서 화면 전환을 처리하려면 대상이 되는 뷰 컨트롤러의 정보를 읽어와 직접 인스턴스화 한 후에 화면을 전환해야 하지만, 세그웨이를 이용하면 뷰 컨트롤러에 대한 정보가 없어도 된다. 또한 뷰 컨트롤러의 객체를 생성할 필요도 없다. 세그웨이가 스토리보드상의 연결 정보를 이용하여 대상 뷰 컨트롤러의 인스턴스를 자동으로 만들어주기 때문이다. 세그웨이가 실행되는 순간 스토리보드를 통하여 이미 세그웨이의 출발지와 목적지 뷰 컨트롤러에 대한 인스턴스가 생성되고, 그 포인터가 세그웨이 객체에 설정된다. 
- 세그웨이의 목적지는 당연 뷰 컨트롤러 이지만, 출발점은 뷰 컨트롤러 자체가 될 수도 있고 버튼이나 테이블 셀 등의 컨트롤이 될 수도 있다. 출발점이 뷰 컨트롤러 자체인 경우를 **매뉴얼 세그웨이(Manual Segue)** , 버튼 등이 출발점인 경우를 **액션 세그웨이(Action Segue)** 또는 **트리거 세그웨이(Trigger Segue)** 라고 나누어 부르기도 한다. 이 구분은 세그웨이를 실행하는 방식에서만 차이가 있을 뿐, 두 가지 방식 모두 세그웨이를 실행하기만 하면 화면 전환이 이루어진다는 점에서 공통이다. 
- 매뉴얼 세그웨이를 실행하려면 UIKit 프레임워크에 정의된 performSegue(withIdentifier : sender :) 메소드를 사용한다. 반면 액션 세그웨이는 버튼의 터치 이벤트가 세그웨이 실행으로 바로 연결되므로, 소스 코드를 추가하지 않아도 화면 전환 기능을 구현 할 수 있다. 

 ### 4.5.1 액션 세그웨이 

- 액션 세그웨이는 트리거(Trigger) 와 세그웨이가 직접 연결된 것을 의미한다. **트리거** 란 방아쇠라는 뜻의 영어 단어로, 터치 또는 클릭 이벤트를 발생시켜 세그웨이를 실행할 수 있는 요소를 말한다. 주로 버튼이나 테이블 셀 등의 컨트롤과 손가락으로 그리는 특정 패턴을 인식하는 제스처 등이 이에 해당
- 액션 세그웨이는 화면 전환을 위해 프로그래밍 코드가 일절 필요하지 않을 뿐만 아니라, 스토리보드에 구현된 객체를 트리거로 지정하기만 하면 되므로 전체적인 구성이 굉장히 단순해진다는 장점이 있다. 게다가, 프로그래밍 코드를 사용할 때보다 비교도 안되게 빠른 시간 내에 화면 이동을 구현할 수도 있다. 
- 세그웨이 연결 옵션 중에서 [Present Modally] 항목은 화면 전환 메소드 중 present(animated :) 메소드를 이용한 화면 전환과 같은 기능을 한다. 
- 소스 코드를 이용하여 화면 전환을 처리하면 스토리보드에 아무런 표시가 남지 않아 화면끼리의 연결 관계를 유추하기 힘들지만, 세그웨이를 이용하면 이처럼 스토리보드에 화면 전환 관계가 명료하게 표시되므로 직관적으로 화면 사이의 관계를 파악할 수 있어 좋다. 
- 화살표 중간에 있는 아이콘은 세그웨이의 타입을 이미지화하여 보여준다. 

### 4.5.2 매뉴얼 세그웨이

- 매뉴얼 세그웨이는 해당 이벤트만 발생하면 자동으로 실행되는 액션 세그웨이와 달리 뷰 컨트롤러와 뷰 컨트롤러 사이에 연결되는 수동 실행 세그웨이 이다. 

- 액션 세그웨이는 트리거의 터치에 의해 실행되므로 별도의 처리 코드가 전혀 필요없지만, 매뉴얼 세그웨이는 트리거 없이 수동으로 실행해야 하므로 소스 코드에서 세그웨이를 실행할 메소드를 호출해야 한다. 

- 메뉴얼 세그웨이를 실행하기 위한 메소드 

  ```swift
  performSegue(withIdentifier : <세그웨이 식별자>, sender: <세그웨이 실행 객체>)
  ```

  두 개의 인자값은  세그웨이가 여러 개일 경우를 대비한 세그웨이 식별자와 세그웨이를 실행하는 객체 정보이다. 필요한 시점에서 세그웨이 식별자를 통해 특정 세그웨이를 지정하고 위 메소드를 호출하면, 세그웨이가 실행되면서 화면이 전환되는 구조라고 보면 된다. 

- 추가된 매뉴얼 세그웨이를 메소드에서 호출하려면 세그웨이에 식별자를 부여해야 한다.  세그웨이를 선택하고 어트리뷰트 인스펙터 탭을 열고 [Identifier] 항목에 'ManualWind' 라고 입력한다. 여기서 입력하는 값은 잠시 후 소스 코드에서 메소드의 인자값으로 사용하게 된다. 꼭 'ManualWind' 라고 입력할 필요는 없지만 입력한 값은 대소문자 및 오타에 유의하자. 

- 다음으로 할 일은 매뉴얼 세그웨이를 실행할 액션 메소드를 만들어 주는 것이다. 버튼을 추가하고 보조 에디터에 드래그 하여 @IBAction 메소드를 추가한다. 

  ```swift
  @IBAction func wind (_ sender : Any) {
    // 세그웨이를 실행한다. 
    self.performSegue(withIdentifier : "ManualWind", sender : self)
  }
  ```

- 세그웨이에서도 화면 전환 효과를 줄 수있다. 스토리보드에서 추가했던 세그웨이를 선택하고 어트리뷰트 인스펙터 탭을 열어 [Storyboard Segue] -> [Transition] 항목을 찾아 선택값 목록을 열어서 선택하면 된다. 

  - Default
  - Cover Vertical 
  - Flip Horizontal
  - Cross Dissolve
  - Partial Curl 

### 4.5.3 Unwind - 화면 복귀

- 이전 화면으로 돌아가는 것을 공식 용어로 **Unwind** 라고 한다. 새로운 화면으로 전환하는 것을 **Wind** 라고 한다면, Unwind 는 Wind 작업을 해제한다는 의미라고 볼 수 있다. 

- 세그웨이를 이용한 Unwind는 안될까? 결론은 안된다. 첫번째 뷰 컨트롤러에서 두 번째 뷰 컨트롤러로의 화면 전환은 문제가 없지만 두번째 뷰 컨트롤러에서 첫 번째 뷰 컨트롤러로 돌아가려고 하면 오류가 발생하면서 앱이 종료된다. 

- 세그웨이는 목적지가 되는 뷰 컨트롤러의 인스턴스를 자동으로 생성한다. 따라서 두 번째 뷰 컨트롤러에서 첫 번째 뷰 컨트롤러로 세그웨이를 연결하면 자동으로  첫 번째 뷰 컨트롤러의 인스턴스가 만들어진다. 하지만 이미 첫 번째 뷰 컨트롤러의 인스턴스가 존재하는 상황이다. 역방향의 세그웨이를 다시 생성한다는 것은 이미 존재하는 뷰 컨트롤러의 인스턴스를 또 다시 만들어 낸다는 의미이다. 동일한 뷰 컨트롤러가 중복된다는 뜻이다. 이 때문에 앱에서 앱에서 오류가 발생할 수 있다. 

- 그렇다면 Unwind는 어떤 방식으로 구현하면 될까? 

   1) 이미 배운 화면 복귀용 메소드를 이용하는 방법. 

  	  - 프레젠테이션 방식으로 이동했을때 : dismiss(animated :)
  	  - 내비게이션 컨트롤러를 이용하여 이동했을 때 : popViewController(animated : )

  2)  세그웨이 구조에서 제공하는 이른바 Unwind Segue 를 이용하는 방법

  - 스토리보드의 뷰 컨트롤러 상단에 나타나는 도크 바의 아이콘 중에서 세 번째 아이콘에 마우스를 올려보면 Exit 라는 툴팁이 있다. 바로 이 Exit 를 이용해서 현재 화면을 종료하고 이전 화면으로 되돌아가는 Unwind Segue 를 구현할 수 있다. ;

- 뷰 컨트롤러 A 에서 뷰 컨트롤러 B 로 화면을 이동했다고 할때, 다시 원래의 뷰 컨트롤러 A 로 되돌아가기 위한 Unwind Segueway 의 구현 방법

  ​	1) 뷰 컨트롤러 A 에 UIStoryboardSegue 타입의 인자값을 받는 @IBAction 액션 메소드를 정의한다. 이를 'Unwind Segue' 메소드 라고 부른다. 이때 메소드를 버튼과 연결할 필요는 없다

  ​	2) 뷰 컨트롤러 B 에 버튼을 만들고 이를 Exit 아이콘에 드래그 한다. 트리거를 생성하는 것.

  ​	3) 버튼이 드래그된 Exit 아이콘은 1) 에서 생성한 메소드를 인식하고, 이를 찾아 Unwind Segue로 자동 생성 해준다. 

  이 과정에서 Exit 아이콘에 버튼을 연결하는 것은 뷰 컨트롤러 B 이지만, Unwind Segue 메소드를 만들어야 하는 곳은 뷰 컨트롤러 A 이다. 

### 4.5.4 커스텀 세그웨이

- 우리가 지금까지 사용했던 세그웨이 객체는 UIKit 프레임워크에서 제공하는 UIStoryboardSegue 클래스를 통해 구현된 객체이다. 그런데 앱을 제작하다 보면 기본적인 기능의 세그웨이로는 원하는 기능을 충분히 구현하기 어려운 경우가 종종 생긴다. 이럴 때를 대비하여 UIKit 프레임워크는 UIStoryboardSegue 클래스를 서브클래싱하여 새로운 기능을 갖춘 세그웨이 객체를 정의할 수 있도록 지원한다. 

